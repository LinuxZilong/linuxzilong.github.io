https://www.cnblogs.com/cangqinglang/p/12101493.html

要实现并行执行，可以使用并行处理工具，例如GNU Parallel，xargs或者&操作符。

## 串行改为并行 

首先，先来看一个串行的例子：

```bash
for i in `seq 1 10`;do
    sleep 1; 
    echo $i
done
```

这是一个迭代次数为10的循环，每一个循环都会等待 1 秒，执行总时长约等于 10 秒。`sleep 1` 会阻塞循环，只有 `sleep 1` 执行结果，才会进入下一循环，这是典型的串行模式。

shell 提供了一种把命令提交到后台任务队列的机制，即使用 `命令 &` 将命令控制权交到后台并立即返回执行下个任务。

```bash
for i in `seq 1 10`; do
    sleep 1 & 
    echo $i;
done
```

还是这个例子，多了个 `&` 符，其作用是将命令 `sleep 1` 提交到后台去执行，而 for 无须等待就可进入下一次循环。所以上面的 for 循环在 1 秒未到的时间内就执行完毕，然后系统会逐个执行 `sleep 1` 并向终端报告命令执行结束。


需要在 `echo "all weakup"` 命令之前，加上 `wait`命令，意为等待上面所有 `&` 作用过的后台任务执行结束后才继续往下。

```bash
for i in `seq 1 10`;do
    sleep 5 &
    echo $i
done
wait
echo "all weakup"
```



### 方案1-控制一次性提交的后台任务数量

上要求 for 循环有部分执行或循环达到一定次数后就要 `wait`，等待前一批次的所提交的任务执行完之后，再提交一定数量命令（再循环一定次数）后再继续 `wait`。虽然这种方案并不优雅，但至少不会导致一次性向系统提交过多后台任务。

看看下面的例子：

```bash
degree=4
for i in `seq 1 10`;do
    sleep 1 & # 提交到后台的任务
    echo $i
    [ `expr $i % $degree` -eq 0 ] && wait
done
```

上面示例，设置了一个变量 `degree`，用来表示并行度，在整个循环中控制阻塞的关键就是于语句 `[ ``expr $i % $degree`` -eq 0 ] && wait`，即在第 n 次循环时，如果 n 恰好对 degree 求模等于0时，那么循环先阻塞，等待前面 n 个后台任务执行完毕后再继续，以此类推。

### 方案2-利用队列来控制提交的任务数量

> 并行度控制，原理还不算复杂，但因为 shell 的原生数据结构支持较弱，使用 shell 来实现并行度控制就比较麻烦。

与 c、java、python 等语言实现并行度的原理基本一致，都是设置一个类似线程池或者工作池的数组，

### 方案3-利用命名管道来做任务队列

大致原理是创建一个 _FIFO_ 命名管道来做为队列，先放进一定量的字符到这个管道做为信号。然后在一个 for 循环中，每循环一次，从管道中读取一个字符信号，提交一个后台任务，并往这个管道中追加一个字符信号，保持管道中的字符信号数量。

是不是很像当 java 中的线程池、golang 中的 _chan_。没有接触过命名管理、文件描述符等概念的，可能会比较难以理解下面示例中的部分细节。

```bash
_fifofile="$$.fifo"
mkfifo $_fifofile     # 创建一个FIFO类型的文件
exec 6<>$_fifofile    # 将文件描述符6写入 FIFO 管道， 这里6也可以是其它数字
rm $_fifofile         # 删也可以，

degree=4  # 定义并行度

#根据并行度设置信号个数
#事实上是在fd6中放置了$degree个回车符
for ((i=0;i<${degree};i++));do
    echo
done >&6

for i in `seq 1 20`;do # 循环20次
    # 从管道中读取（消费掉）一个字符信号
    # 当FD6中没有回车符时，停止，实现并行度控制
    read -u6
    {
        sleep 1  # 实际任务的命令
        echo $i
        echo >&6 # 当进程结束以后，再向管道追加一个信号，保持管道中的信号总数量
    } &
done
wait # 等待所有任务结束
exec 6>&- # 关闭管道
```

_方案1-控制一次性提交的后台任务数量_ 是采用分批次提交的思路，而 _方案2_ 则是利用消费命名管道时`read` 会出现等待的特性，因为是每执行完一个任务后就追加一个信号，等同释放一个任务执行名额，总是保持任务并行执行数为 degree。

因为采用队列模型，当执行完一个任务，马上就会有另一个任务被启动，在服务系统设计时，这种模式的任务控制是系统资源利用率最高的。

### 方案4-使用 xargs 命令的控制参数 [#](https://youwu.today/blog/parallel-in-shell/#%e6%96%b9%e6%a1%884-%e4%bd%bf%e7%94%a8-xargs-%e5%91%bd%e4%bb%a4%e7%9a%84%e6%8e%a7%e5%88%b6%e5%8f%82%e6%95%b0)

###  `xargs` 有一个控制并行的参数。

```bash
seq 20 | xargs -I % -P4 sh -c 'echo %; sleep 1'
```

关键在于 `xargs` 的 `-P` 参数，指一次性接收多少个参数，默认为1。使用 `-I %` 指定在命令中可以使用 `%` 符来表示接收到的参数

### 方案5-使用 parallel 命令行工具 

在 _gnu linux_ 的生态中，有一个专门用来处理本文所述并行控制场景的工具，名字叫 _parallel_。

> [官方链接](https://www.gnu.org/software/bash/manual/html_node/GNU-Parallel.html)

下面还是使用打印序列号的例子来演示如果控制并行：

```bash
seq 20 | parallel -j 4 "echo {}; sleep 1"
```

命令格式与 `xargs` 类似，使用 `-j` 来指定并行度；使用 `{}` 来表示参数。
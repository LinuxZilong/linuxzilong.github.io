---
toc: true
categories:
  - blog
  - posts
  - RS路由交换
  - 1.网络协议基础理论
series:
  - 网络协议
title: TCP/UDP
---
https://zhuanlan.zhihu.com/p/133307545  (进阶)

https://zhuanlan.zhihu.com/p/86426969

https://www.sohu.com/a/459280570_261288

https://www.zhihu.com/question/271701044/answer/1808988570

抓包reset

https://www.cnblogs.com/nmap/p/6291683.html

<!--more-->

## 简介

 TCP 是一种可靠的协议，解决：乱序、丢包重传、流控、拥塞控制。

- TCP 在网络 OSI 七层模型中的第四层，TCP 包是没有 IP 地址的，但有源端口和目的端口，用来标识通信的进程。
- Sequence Number 是记录包的序号，TCP 会按照报文字节进行编号，它是用来解决包在网络中乱序的问题。
- Acknowledgement Number 确认序列号，是用于向发送方确认已经收到了哪些包，用来解决不丢包的问题。
- Windows 也叫 Advertised-Windows ，也就是著名的滑动窗口，主要是用来解决流控的。
- TCP Flag 就是包的类型，主要是用于操控 TCP 状态机的。

## 什么是SYN攻击

SYN Flood攻击属于DDoS攻击的一种，它利用[TCP协议](https://baike.baidu.com/item/TCP协议)缺陷，通过发送大量的[半连接](https://baike.baidu.com/item/半连接)请求，耗费[CPU](https://baike.baidu.com/item/CPU)和内存资源。

服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击

我们使用系统自带的netstat 工具来检测SYN攻击：
```
netstat -n -p TCP | grep SYN_RECV
tcp　0　 0 10.11.11.11:23　124.173.152.8:25882　 SYN_RECV　-
tcp　0　 0 10.11.11.11:23　236.15.133.204:2577　 SYN_RECV　-
tcp　0　 0 10.11.11.11:23　127.160.6.129:51748　 SYN_RECV　-
tcp　0　 0 10.11.11.11:23　222.220.13.25:47393　 SYN_RECV　-
tcp　0　 0 10.11.11.11:23　212.200.204.182:60427 SYN_RECV　-
tcp　0　 0 10.11.11.11:23　232.115.18.38:278　 SYN_RECV　-
tcp　0　 0 10.11.11.11:23　239.116.95.96:5122　SYN_RECV　-
tcp　0　 0 10.11.11.11:23　236.219.139.207:49162 SYN_RECV　-
上面是在LINUX系统中看到的，很多连接处于SYN_RECV状态（在WINDOWS系统中是SYN_RECEIVED状态），源IP地址都是随机的，表明这是一种带有IP欺骗的SYN攻击。
常见的防御 SYN 攻击的方法有如下几种：

缩短超时（SYN Timeout）时间
增加最大半连接数
过滤网关防护
SYN cookies技术
```

## 名词解释：

seq：占 4 字节，序号范围[0，2^32-1]，序号增加到 2^32-1 后，下个序号又回到 0。

ACK (Acknowledge character）即是确认字符，在数据通信中，接收站发给发送站的一种传输类[控制字符](https://baike.baidu.com/item/控制字符/6913704)。表示发来的数据已确认接收无误。

SYN：同步序列编号（***Synchronize Sequence Numbers\***）。是TCP/IP建立连接时使用的握手信号。

## 三次握手

![img](https://image-fusice.oss-cn-hangzhou.aliyuncs.com/image/TCPUDP/2021.04.14-11:37:54-D-assets-TCPUDP-f8486c4397534ae8a9b110356fc91c19.png)

- 第一次握手：客户端发送 SYN 报文，并进入 SYN_SENT 状态，等待服务器的确认；

- 第二次握手：服务器收到 SYN 报文，需要给客户端发送 ACK 确认报文，同时服务器也要向客户端发送一个 SYN 报文，所以也就是向客户端发送 SYN + ACK 报文，此时服务器进入 SYN_RCVD 状态；

- 第三次握手：客户端收到 SYN + ACK 报文，向服务器发送确认包，客户端进入 ESTABLISHED 状态。待服务器收到客户端发送的 ACK 包也会进入 ESTABLISHED 状态，完成三次握手。

  > - 第一次握手：客户端发送 SYN 报文，并指明客户端的初始化序列号 ISN，并进入 SYN_SENT 状态，等待服务器的确认；
  >   首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。
  > - 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，所以也就是向客户端发送 SYN + ACK 报文，此时服务器进入 SYN_RCVD 状态；
  > - 第三次握手：客户端收到  SYN + ACK 报文之后，会把服务器的 ISN + 1 作为 ACK 的值发送给服务器，，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。

> 问：为什么 TCP 采用三次握手，二次握手可以吗？

> 第一次握手：客户端发送网络包，服务端收到了。
>
> 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
>
> 第二次握手：服务端发包，客户端收到了。
>
> 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
>
> 第三次握手：客户端发包，服务端收到了。
>
> 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。
>
> 因此，需要三次握手才能确认双方的接收与发送能力是否正常。
>
> 试想如果是用两次握手，则会出现下面这种情况：
>
> > 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。

**（一）确认双方的收发能力**

TCP 建立连接之前，需要确认客户端与服务器双方的收包和发包的能力。

1. 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

2. 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。

3. 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

所以，只有三次握手才能确认双方的接收与发送能力是否正常。

**（二）序列号可靠同步**

如果是两次握手，服务端无法确定客户端是否已经接收到了自己发送的初始序列号，如果第二次握手报文丢失，那么客户端就无法知道服务端的初始序列号，那 TCP 的可靠性就无从谈起。

**（三）阻止重复历史连接的初始化**

客户端由于某种原因发送了两个不同序号的 SYN 包，我们知道网络环境是复杂的，旧的数据包有可能先到达服务器。如果是两次握手，服务器收到旧的 SYN 就会立刻建立连接，那么会造成网络异常。

如果是三次握手，服务器需要回复 SYN+ACK 包，客户端会对比应答的序号，如果发现是旧的报文，就会给服务器发 RST 报文，直到正常的 SYN 到达服务器后才正常建立连接。

所以三次握手才有足够的上下文信息来判断当前连接是否是历史连接。

**（四）安全问题**

我们知道 TCP 新建连接时，内核会为连接分配一系列的内存资源，如果采用两次握手，就建立连接，那会放大 DDOS 攻击的。

TCP 作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而三次握手恰好可以满足以上两方面的需求！

> 问：初始序列号（ISN）代表什么？意义何在？ISN 是固定不变的吗？ISN为何要动态随机？

**ISN 是什么？**

答： ISN 全称是 Initial Sequence Number ，是 TCP 发送方的字节数据编号的原点，告诉对方我要开始发送数据的初始化序列号

**ISN 是固定不变的吗？**

答：ISN 如果是固定的，攻击者很容易猜出后续的确认序号，为了安全起见，避免被第三方猜到从而发送伪造的 RST 报文，因此 ISN 是动态生成的

> 什么是半连接队列？

答：服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立连接。服务器会把这种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。

当然还有一个 全连接队列 ，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

> 问：三次握手过程中，可以携带数据吗？

答：第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。

我们可以思考一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，疯狂着重复发 SYN 报文，这会让服务器花费大量的内存空间来缓存这些报文，这样服务器就更容易被攻击了。

对于第三次握手，此时客户端已经处于连接状态，他已经知道服务器的接收、发送能力是正常的了，所以可以携带数据是情理之中。

## TCP 四次挥手

![img](https://image-fusice.oss-cn-hangzhou.aliyuncs.com/image/TCPUDP/2021.04.14-14:13:21-D-assets-TCPUDP-9e1534350c0b4d37ae0c7a1a61d90d47.png)

- 第一次挥手。客户端发起 FIN 包（FIN = 1）,客户端进入 FIN_WAIT_1 状态。TCP 规定，即使 FIN 包不携带数据，也要消耗一个序号。
- 第二次挥手。服务器端收到 FIN 包，发出确认包 ACK （ack = u + 1），并带上自己的序号 seq=v，服务器端进入了 CLOSE_WAIT 状态。这个时候客户端已经没有数据要发送了，不过服务器端有数据发送的话，客户端依然需要接收。客户端接收到服务器端发送的 ACK 后，进入了 FIN_WAIT_2 状态。
- 第三次挥手。服务器端数据发送完毕后，向客户端发送 FIN 包（seq=w ack=u+1），半连接状态下服务器可能又发送了一些数据，假设发送 seq 为 w。服务器此时进入了 LAST_ACK 状态。
- 第四次挥手。客户端收到服务器的 FIN 包后，发出确认包（ACK=1，ack=w+1），此时客户端就进入了 TIME_WAIT 状态。注意此时 TCP 连接还没有释放，必须经过 2*MSL 后，才进入 CLOSED 状态。而服务器端收到客户端的确认包 ACK 后就进入了 CLOSED 状态，可以看出服务器端结束 TCP 连接的时间要比客户端早一些。

> 问：为什么建立连接握手三次，关闭连接时需要是四次呢？

答：其实在 TCP 握手的时候，接收端发送 SYN+ACK 的包是将一个 ACK 和一个 SYN 合并到一个包中，所以减少了一次包的发送，三次完成握手。

对于四次挥手，因为 TCP 是全双工通信，在主动关闭方发送 FIN 包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的 FIN 包与对客户端的 ACK 包合并发送，只能先确认 ACK ，然后服务器待无需发送数据时再发送 FIN 包，所以四次挥手时必须是四次数据包的交互。

> 问：为什么TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态？

答： MSL 指的是报文在网络中最大生存时间。在客户端发送对服务器端的 FIN 的确认包 ACK 后，这个 ACK 包是有可能不可达的，服务器端如果收不到 ACK 的话需要重新发送 FIN 包。

所以客户端发送 ACK 后需要留出 2MSL 时间（ACK 到达服务器 + 服务器发送 FIN 重传包，一来一回）等待确认服务器端确实收到了 ACK 包。

也就是说客户端如果等待 2MSL 时间也没有收到服务器端的重传包 FIN ，说明可以确认服务器已经收到客户端发送的 ACK 。

还有第 2 个理由，避免新旧连接混淆。

在客户端发送完最后一个 ACK 报文段后，在经过 2MSL 时间，就可以使本连接持续的时间内所产生的所有报文都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文。

你要知道，有些自作主张的路由器会缓存 IP 数据包，如果连接重用了，那么这些延迟收到的包就有可能会跟新连接混在一起。

## 《TCP/IP详解 卷1:协议》TCP状态变迁图

![img](https://image-fusice.oss-cn-hangzhou.aliyuncs.com/image/TCPUDP/2021.04.14-14:23:43-D-assets-TCPUDP-v2-7c402fde8210519feb8f65d41410c205_r.jpg)
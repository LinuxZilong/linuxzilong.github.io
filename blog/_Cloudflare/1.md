在上一篇文章中，我们演练了成功安装 Cert-Manager 来处理所有入口的 SSL 证书分配的过程。虽然有优势，但这种方法也带来了一些值得注意的挑战：

有效期有限：Cert-Manager 提供的证书的有效期很短（90 天），这意味着使用该服务的任何第三方系统可能需要每 90 天更新其证书白名单。
不适合生产环境：Let's Encrypt 提供的证书虽然有用，但可能不适合生产环境。
打开端口 80：为了验证和颁发证书，Cert-Manager 要求在此过程中在端口 80 上使用不安全的 HTTP。但是，如果出于任何原因，基础设施团队不愿意将端口 80 暴露给互联网，那么 Cert-Manager 的运行可能会受到影响。
潜在的 Cert-Manager 故障：在某些情况下，Cert-Manager 可能会遇到问题并且无法续订证书。在这种情况下，第三方系统可能会因证书验证失败而无法访问我们的服务。



kubectl create secret tls tls-drunkcoding-net-import --cert=cert.crt --key=private.key --namespace=our-namespace




apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: echo-ingress
  namespace: default
  annotations:
    kubernetes.io/tls-acme: "true"
spec:
  ingressClassName: nginx
  tls:
    - hosts:
        - echo.drunkcoding.net
      # only need to change this secret name.
      secretName: tls-drunkcoding-net-imported
  rules:
    - host: echo.drunkcoding.net
      http:
        paths:
          - pathType: Prefix
            path: "/"
            backend:
              service:
                name: echo-service
                port:
                  number: 80